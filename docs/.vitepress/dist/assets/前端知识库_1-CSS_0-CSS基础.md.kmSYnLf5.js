import{_ as t,c as e,o as i,aS as o}from"./chunks/framework.CYhLyFt1.js";const b=JSON.parse('{"title":"CSS基础","description":"","frontmatter":{},"headers":[],"relativePath":"前端知识库/1-CSS/0-CSS基础.md","filePath":"前端知识库/1-CSS/0-CSS基础.md","lastUpdated":1712717365000}'),d={name:"前端知识库/1-CSS/0-CSS基础.md"},a=o('<h1 id="css基础" tabindex="-1">CSS基础 <a class="header-anchor" href="#css基础" aria-label="Permalink to &quot;CSS基础&quot;">​</a></h1><h2 id="对盒模型的理解" tabindex="-1">对盒模型的理解 <a class="header-anchor" href="#对盒模型的理解" aria-label="Permalink to &quot;对盒模型的理解&quot;">​</a></h2><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型</p><p><img src="https://cdn.jsdelivr.net/gh/viteui/viteui.github.io/web/image/202306122133786.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/viteui/viteui.github.io/web/image/202306122133722.png" alt=""></p><p>盒模型都是由四个部分组成的，分别是 <code>margin</code>、<code>border</code>、<code>padding</code>和 <code>content</code>。</p><p>标准盒模型和IE盒模型的区别在于设置 <code>width</code>和 <code>height</code>时，所对应的范围不同：</p><ul><li>标准盒模型的 <code>width</code>和 <code>height</code>属性的范围只包含了 <code>content</code>，</li><li>IE盒模型的 <code>width</code>和 <code>height</code>属性的范围包含了 <code>border</code>、<code>padding</code>和 <code>content</code>。</li></ul><p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p><ul><li><code>box-sizing: content-box</code>表示标准盒模型（默认值）</li><li><code>box-sizing: border-box</code>表示IE盒模型（怪异盒模型）</li></ul><h2 id="css定位" tabindex="-1">CSS定位 <a class="header-anchor" href="#css定位" aria-label="Permalink to &quot;CSS定位&quot;">​</a></h2><table><thead><tr><th>属性值</th><th>概述</th></tr></thead><tbody><tr><td>absolute</td><td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>relative</td><td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td></tr><tr><td>fixed</td><td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td></tr><tr><td>static</td><td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td></tr><tr><td>inherit</td><td>规定从父元素继承position属性的值</td></tr></tbody></table><p>前面三者的定位方式如下：</p><ul><li><strong>relative：</strong> 元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/viteui/viteui.github.io/web/image/202306130014975.png" alt=""></p><ul><li><strong>fixed：</strong> 元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/viteui/viteui.github.io/web/image/202306130014534.png" alt=""></p><ul><li><strong>absolute：</strong> 元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了 <code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</li></ul><p><img src="https://cdn.jsdelivr.net/gh/viteui/viteui.github.io/web/image/202306130014023.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/viteui/viteui.github.io/web/image/202306130015721.png" alt=""></p><p><strong>sticky</strong> ：元素根据正常文档流进行定位，然后相对它的最近滚动祖先（nearest scrolling ancestor）和 containing block (最近块级祖先 nearest block-level ancestor)，包括 table-related 元素，基于top, right, bottom, 和 left的值进行偏移。偏移值不会影响任何其他元素的位置。该值总是创建一个新的层叠上下文（stacking context）。注意，一个 sticky 元素会“固定”在离它最近的一个拥有“滚动机制”的祖先上（当该祖先的overflow 是 hidden, scroll, auto, 或 overlay时），即便这个祖先不是最近的真实可滚动祖先。这有效地抑制了任何“sticky”行为</p><p><img src="https://cdn.jsdelivr.net/gh/viteui/viteui.github.io/web/image/202308182204869.awebp" alt=""></p><h2 id="css选择器优先级" tabindex="-1">CSS选择器优先级 <a class="header-anchor" href="#css选择器优先级" aria-label="Permalink to &quot;CSS选择器优先级&quot;">​</a></h2><ul><li>important &gt; 内联 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 继承 &gt; 通配符</li></ul>',24),r=[a];function c(l,s,n,h,g,p){return i(),e("div",null,r)}const S=t(d,[["render",c]]);export{b as __pageData,S as default};
